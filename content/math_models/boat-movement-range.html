<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boat Movement Range Visualizer</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        label {
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
            cursor: pointer;
        }
        
        input[type="number"] {
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .value-display {
            font-size: 0.9em;
            color: #666;
            text-align: right;
            font-weight: 500;
        }
        
        button {
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        #canvas {
            border: 3px solid #333;
            border-radius: 15px;
            display: block;
            margin: 0 auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            background: #fff;
            cursor: crosshair;
        }
        
        .info {
            margin-top: 20px;
            padding: 15px;
            background: #f0f4f8;
            border-radius: 10px;
            font-size: 14px;
            color: #666;
            border-left: 4px solid #667eea;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            color: #666;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #333;
        }
        
        .status {
            margin-top: 15px;
            padding: 10px;
            background: #e8f4f8;
            border-radius: 8px;
            text-align: center;
            font-weight: 600;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸš¤ Boat Movement Range Visualizer</h1>
        
        <div class="controls">
            <div class="control-group">
                <label for="maxAccel">Max Acceleration (m/sÂ²)</label>
                <input type="number" id="maxAccel" value="2" step="0.5" min="0.5" max="10">
            </div>
            
            <div class="control-group">
                <label for="maxDecel">Max Deceleration (m/sÂ²)</label>
                <input type="number" id="maxDecel" value="3" step="0.5" min="0.5" max="10">
            </div>
            
            <div class="control-group">
                <label for="maxSpeed">Max Speed (m/s)</label>
                <input type="number" id="maxSpeed" value="20" step="1" min="1" max="50">
            </div>
            
            <div class="control-group">
                <label for="turningRange">Max Turn Rate (Â°/s)</label>
                <input type="range" id="turningRange" min="5" max="180" value="90" step="5">
                <span class="value-display" id="turningDisplay">90Â°/s</span>
            </div>
            
            <div class="control-group">
                <label for="initialVx">Initial Velocity X (m/s)</label>
                <input type="number" id="initialVx" value="0" step="1" min="-50" max="50">
            </div>
            
            <div class="control-group">
                <label for="initialVy">Initial Velocity Y (m/s)</label>
                <input type="number" id="initialVy" value="0" step="1" min="-50" max="50">
            </div>
            
            <div class="control-group">
                <label for="gridDensity">Grid Density</label>
                <input type="range" id="gridDensity" min="10" max="100" value="30" step="5">
                <span class="value-display" id="densityDisplay">30</span>
            </div>
            
            <div class="control-group">
                <label for="timeInterval">Time Interval (s)</label>
                <input type="number" id="timeInterval" value="10" step="1" min="1" max="30">
            </div>
            
            <div class="control-group">
                <label for="initialAngle">Initial Heading (Â°)</label>
                <input type="range" id="initialAngle" min="0" max="360" value="0" step="15">
                <span class="value-display" id="angleDisplay">0Â°</span>
            </div>
            
            <div class="control-group">
                <button onclick="calculate()">Calculate Range</button>
            </div>
        </div>
        
        <canvas id="canvas" width="800" height="800"></canvas>
        
        <div class="status" id="status">Click on any point to see if the boat can reach it and visualize the path</div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(0, 255, 0, 0.8);"></div>
                <span>Reachable Position</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(255, 0, 0, 0.3);"></div>
                <span>Unreachable Position</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FFD700;"></div>
                <span>Boat Starting Position</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #4169E1;"></div>
                <span>Boat at Destination</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(65, 105, 225, 0.5);"></div>
                <span>Path Taken</span>
            </div>
        </div>
        
        <div class="info">
            <strong>How to use:</strong> 
            <ul style="margin: 5px 0; padding-left: 20px;">
                <li>Click "Calculate Range" to show all reachable positions</li>
                <li>Click on any point to see if the boat can reach it</li>
                <li>If reachable, the blue path shows how the boat gets there</li>
                <li>The boat orientation at the destination is shown in blue</li>
                <li>Set initial velocities to simulate a moving start</li>
            </ul>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let gridCalculated = false;
        let gridResults = {};
        let currentPath = null;
        
        // Update display values
        document.getElementById('turningRange').addEventListener('input', (e) => {
            document.getElementById('turningDisplay').textContent = e.target.value + 'Â°/s';
        });
        
        document.getElementById('gridDensity').addEventListener('input', (e) => {
            document.getElementById('densityDisplay').textContent = e.target.value;
        });
        
        document.getElementById('initialAngle').addEventListener('input', (e) => {
            document.getElementById('angleDisplay').textContent = e.target.value + 'Â°';
        });
        
        // Add click handler
        canvas.addEventListener('click', handleCanvasClick);
        
        function simulatePathToTarget(targetX, targetY, params) {
            const {
                maxAccel,
                maxDecel,
                maxSpeed,
                maxTurnRate,
                timeLimit,
                initialHeading,
                initialVx,
                initialVy
            } = params;
            
            // Convert to radians
            const maxTurnRad = maxTurnRate * Math.PI / 180;
            const initialHeadingRad = initialHeading * Math.PI / 180;
            
            // Simulation parameters
            const dt = 0.1; // Time step
            let t = 0;
            let x = 0, y = 0;
            let vx = initialVx, vy = initialVy;
            let heading = initialHeadingRad;
            
            // Path recording
            const path = [{x, y, vx, vy, heading, t: 0}];
            
            while (t < timeLimit) {
                // Calculate error to target
                const dx = targetX - x;
                const dy = targetY - y;
                const distToTarget = Math.sqrt(dx * dx + dy * dy);
                
                if (distToTarget < 2) { // Close enough
                    return {
                        reached: true,
                        path: path,
                        finalHeading: heading,
                        finalX: x,
                        finalY: y
                    };
                }
                
                // Desired heading to target
                const desiredHeading = Math.atan2(dy, dx);
                
                // Calculate heading error
                let headingError = desiredHeading - heading;
                while (headingError > Math.PI) headingError -= 2 * Math.PI;
                while (headingError < -Math.PI) headingError += 2 * Math.PI;
                
                // Turn towards target
                const turnRate = Math.max(-maxTurnRad, Math.min(maxTurnRad, headingError / dt));
                heading += turnRate * dt;
                
                // Current speed
                const speed = Math.sqrt(vx * vx + vy * vy);
                
                // Calculate stopping distance
                const stoppingDist = speed * speed / (2 * maxDecel);
                
                // Decide whether to accelerate or decelerate
                let accel;
                if (distToTarget > stoppingDist + 5 && speed < maxSpeed) {
                    accel = maxAccel;
                } else if (distToTarget < stoppingDist) {
                    accel = -maxDecel;
                } else {
                    accel = 0;
                }
                
                // Apply acceleration in current heading direction
                vx += accel * Math.cos(heading) * dt;
                vy += accel * Math.sin(heading) * dt;
                
                // Limit speed
                const newSpeed = Math.sqrt(vx * vx + vy * vy);
                if (newSpeed > maxSpeed) {
                    vx = vx * maxSpeed / newSpeed;
                    vy = vy * maxSpeed / newSpeed;
                }
                
                // Update position
                x += vx * dt;
                y += vy * dt;
                
                t += dt;
                
                // Record path point every few steps
                if (path.length === 0 || t - path[path.length - 1].t >= 0.3) {
                    path.push({x, y, vx, vy, heading, t});
                }
            }
            
            // Check if we're close enough at the end
            const finalDist = Math.sqrt((targetX - x) * (targetX - x) + (targetY - y) * (targetY - y));
            return {
                reached: finalDist < 5,
                path: path,
                finalHeading: heading,
                finalX: x,
                finalY: y
            };
        }
        
        function handleCanvasClick(event) {
            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;
            
            // Convert to world coordinates
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = 2; // pixels per meter
            
            const worldX = (clickX - centerX) / scale;
            const worldY = (clickY - centerY) / scale;
            
            // Get parameters
            const params = {
                maxAccel: parseFloat(document.getElementById('maxAccel').value),
                maxDecel: parseFloat(document.getElementById('maxDecel').value),
                maxSpeed: parseFloat(document.getElementById('maxSpeed').value),
                maxTurnRate: parseFloat(document.getElementById('turningRange').value),
                timeLimit: parseFloat(document.getElementById('timeInterval').value),
                initialHeading: parseFloat(document.getElementById('initialAngle').value),
                initialVx: parseFloat(document.getElementById('initialVx').value),
                initialVy: parseFloat(document.getElementById('initialVy').value)
            };
            
            // Simulate path to this point
            const result = simulatePathToTarget(worldX, worldY, params);
            currentPath = result;
            
            // Update status
            const status = document.getElementById('status');
            if (result.reached) {
                status.textContent = `âœ“ Target at (${worldX.toFixed(1)}, ${worldY.toFixed(1)}) is REACHABLE - Path shown in blue`;
                status.style.background = '#d4f4dd';
                status.style.color = '#0d7829';
            } else {
                status.textContent = `âœ— Target at (${worldX.toFixed(1)}, ${worldY.toFixed(1)}) is UNREACHABLE`;
                status.style.background = '#ffd4d4';
                status.style.color = '#d32f2f';
            }
            
            // Redraw with the new target
            drawGrid();
            drawTarget(clickX, clickY, result.reached);
            
            if (result.reached) {
                drawPath(result.path);
                drawBoatAtDestination(result.finalX, result.finalY, result.finalHeading);
            }
        }
        
        function drawPath(path) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = 2;
            
            // Draw path line
            ctx.strokeStyle = 'rgba(65, 105, 225, 0.5)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            for (let i = 0; i < path.length; i++) {
                const screenX = centerX + path[i].x * scale;
                const screenY = centerY + path[i].y * scale;
                
                if (i === 0) {
                    ctx.moveTo(screenX, screenY);
                } else {
                    ctx.lineTo(screenX, screenY);
                }
            }
            ctx.stroke();
            
            // Draw path points
            for (let i = 0; i < path.length; i++) {
                const screenX = centerX + path[i].x * scale;
                const screenY = centerY + path[i].y * scale;
                
                ctx.fillStyle = 'rgba(65, 105, 225, 0.3)';
                ctx.beginPath();
                ctx.arc(screenX, screenY, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawBoatAtDestination(x, y, heading) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = 2;
            
            const screenX = centerX + x * scale;
            const screenY = centerY + y * scale;
            
            ctx.save();
            ctx.translate(screenX, screenY);
            ctx.rotate(heading);
            
            // Draw boat triangle (blue at destination)
            ctx.fillStyle = '#4169E1';
            ctx.strokeStyle = '#1e3a8a';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(12, 0);
            ctx.lineTo(-8, -6);
            ctx.lineTo(-8, 6);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            ctx.restore();
        }
        
        function drawTarget(x, y, reachable) {
            ctx.strokeStyle = reachable ? '#00FF00' : '#FF0000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(x, y, 8, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw crosshair
            ctx.beginPath();
            ctx.moveTo(x - 12, y);
            ctx.lineTo(x + 12, y);
            ctx.moveTo(x, y - 12);
            ctx.lineTo(x, y + 12);
            ctx.stroke();
        }
        
        function drawGrid() {
            // Clear canvas
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = 2;
            const gridSize = canvas.width / scale;
            const gridDensity = parseInt(document.getElementById('gridDensity').value);
            const gridStep = gridSize / gridDensity;
            
            // Draw grid lines
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= gridDensity; i++) {
                const pos = i * gridStep * scale;
                ctx.beginPath();
                ctx.moveTo(pos, 0);
                ctx.lineTo(pos, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, pos);
                ctx.lineTo(canvas.width, pos);
                ctx.stroke();
            }
            
            // Draw grid points if calculated
            if (gridCalculated) {
                for (let key in gridResults) {
                    const [i, j] = key.split(',').map(Number);
                    const worldX = (i - gridDensity / 2) * gridStep;
                    const worldY = (j - gridDensity / 2) * gridStep;
                    const screenX = centerX + worldX * scale;
                    const screenY = centerY + worldY * scale;
                    
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, 3, 0, Math.PI * 2);
                    ctx.fillStyle = gridResults[key] ? 'rgba(0, 255, 0, 0.8)' : 'rgba(255, 0, 0, 0.3)';
                    ctx.fill();
                }
            }
            
            // Draw boat starting position and heading
            const initialHeading = parseFloat(document.getElementById('initialAngle').value);
            const initialVx = parseFloat(document.getElementById('initialVx').value);
            const initialVy = parseFloat(document.getElementById('initialVy').value);
            
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(initialHeading * Math.PI / 180);
            
            // Draw boat triangle
            ctx.fillStyle = '#FFD700';
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(15, 0);
            ctx.lineTo(-10, -8);
            ctx.lineTo(-10, 8);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Draw heading indicator
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(50, 0);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.restore();
            
            // Draw velocity vector if non-zero
            if (initialVx !== 0 || initialVy !== 0) {
                ctx.save();
                ctx.translate(centerX, centerY);
                
                const vMag = Math.sqrt(initialVx * initialVx + initialVy * initialVy);
                const vAngle = Math.atan2(initialVy, initialVx);
                
                ctx.strokeStyle = '#FF6B6B';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(initialVx * scale * 2, initialVy * scale * 2);
                ctx.stroke();
                
                // Arrow head
                ctx.save();
                ctx.translate(initialVx * scale * 2, initialVy * scale * 2);
                ctx.rotate(vAngle);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-10, -5);
                ctx.lineTo(-10, 5);
                ctx.closePath();
                ctx.fillStyle = '#FF6B6B';
                ctx.fill();
                ctx.restore();
                
                ctx.restore();
                
                // Label velocity
                ctx.fillStyle = '#FF6B6B';
                ctx.font = 'bold 12px Arial';
                ctx.fillText(`Vâ‚€ = ${vMag.toFixed(1)} m/s`, centerX + 20, centerY - 20);
            }
            
            // Draw center marker
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 4, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function calculate() {
            const maxAccel = parseFloat(document.getElementById('maxAccel').value);
            const maxDecel = parseFloat(document.getElementById('maxDecel').value);
            const maxSpeed = parseFloat(document.getElementById('maxSpeed').value);
            const maxTurnRate = parseFloat(document.getElementById('turningRange').value);
            const gridDensity = parseInt(document.getElementById('gridDensity').value);
            const timeLimit = parseFloat(document.getElementById('timeInterval').value);
            const initialHeading = parseFloat(document.getElementById('initialAngle').value);
            const initialVx = parseFloat(document.getElementById('initialVx').value);
            const initialVy = parseFloat(document.getElementById('initialVy').value);
            
            const params = {
                maxAccel,
                maxDecel,
                maxSpeed,
                maxTurnRate,
                timeLimit,
                initialHeading,
                initialVx,
                initialVy
            };
            
            const gridSize = canvas.width / 2;
            const gridStep = gridSize / gridDensity;
            
            // Calculate reachability for each grid point
            gridResults = {};
            for (let i = 0; i <= gridDensity; i++) {
                for (let j = 0; j <= gridDensity; j++) {
                    const worldX = (i - gridDensity / 2) * gridStep;
                    const worldY = (j - gridDensity / 2) * gridStep;
                    
                    const result = simulatePathToTarget(worldX, worldY, params);
                    gridResults[`${i},${j}`] = result.reached;
                }
            }
            
            gridCalculated = true;
            currentPath = null;
            drawGrid();
            
            document.getElementById('status').textContent = 'Grid calculated! Click on any point to see the path.';
        }
        
        // Initial draw
        drawGrid();
    </script>
</body>
</html>