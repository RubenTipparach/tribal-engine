<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boat Movement Range Visualizer</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        label {
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
            cursor: pointer;
        }
        
        input[type="number"] {
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .value-display {
            font-size: 0.9em;
            color: #666;
            text-align: right;
            font-weight: 500;
        }
        
        button {
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        #canvas {
            border: 3px solid #333;
            border-radius: 15px;
            display: block;
            margin: 0 auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            background: #fff;
            cursor: crosshair;
        }
        
        .info {
            margin-top: 20px;
            padding: 15px;
            background: #f0f4f8;
            border-radius: 10px;
            font-size: 14px;
            color: #666;
            border-left: 4px solid #667eea;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            color: #666;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #333;
        }
        
        .status {
            margin-top: 15px;
            padding: 10px;
            background: #e8f4f8;
            border-radius: 8px;
            text-align: center;
            font-weight: 600;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸš¤ Boat Movement Range Visualizer</h1>
        
        <div class="controls">
            <div class="control-group">
                <label for="flightMode">Flight Mode</label>
                <select id="flightMode" onchange="toggleFlightMode()">
                    <option value="coupled">Coupled (Main Thruster)</option>
                    <option value="decoupled">Decoupled (Maneuvering)</option>
                </select>
            </div>

            <!-- Coupled Mode Controls -->
            <div class="control-group coupled-control">
                <label for="maxAccel">Max Acceleration (m/sÂ²)</label>
                <input type="number" id="maxAccel" value="2" step="0.5" min="0.5" max="10">
            </div>

            <div class="control-group coupled-control">
                <label for="maxDecel">Max Deceleration (m/sÂ²)</label>
                <input type="number" id="maxDecel" value="3" step="0.5" min="0.5" max="10">
            </div>

            <!-- Decoupled Mode Controls -->
            <div class="control-group decoupled-control" style="display: none;">
                <label for="forwardThrust">Forward Thrust (m/sÂ²)</label>
                <input type="number" id="forwardThrust" value="2" step="0.1" min="0" max="5">
            </div>

            <div class="control-group decoupled-control" style="display: none;">
                <label for="backwardThrust">Backward Thrust (m/sÂ²)</label>
                <input type="number" id="backwardThrust" value="2" step="0.1" min="0" max="5">
            </div>

            <div class="control-group decoupled-control" style="display: none;">
                <label for="leftThrust">Left Thrust (m/sÂ²)</label>
                <input type="number" id="leftThrust" value="2" step="0.1" min="0" max="5">
            </div>

            <div class="control-group decoupled-control" style="display: none;">
                <label for="rightThrust">Right Thrust (m/sÂ²)</label>
                <input type="number" id="rightThrust" value="2" step="0.1" min="0" max="5">
            </div>

            <div class="control-group decoupled-control" style="display: none;">
                <label for="targetRotation">Target Rotation (relative Â°)</label>
                <input type="range" id="targetRotation" min="-100" max="100" value="0" step="1">
                <span class="value-display" id="targetRotationDisplay">0Â° (current)</span>
            </div>

            <div class="control-group">
                <label for="maxSpeed">Max Speed (m/s)</label>
                <input type="number" id="maxSpeed" value="20" step="1" min="1" max="50">
            </div>
            
            <div class="control-group">
                <label for="turningRange">Max Turn Rate (Â°/s)</label>
                <input type="range" id="turningRange" min="5" max="180" value="90" step="5">
                <span class="value-display" id="turningDisplay">90Â°/s</span>
            </div>
            
            <div class="control-group">
                <label for="initialVx">Initial Velocity X (m/s)</label>
                <input type="number" id="initialVx" value="0" step="1" min="-50" max="50">
            </div>
            
            <div class="control-group">
                <label for="initialVy">Initial Velocity Y (m/s)</label>
                <input type="number" id="initialVy" value="0" step="1" min="-50" max="50">
            </div>

            <div class="control-group">
                <label for="speedMagnitude">Speed Magnitude (m/s)</label>
                <span class="value-display" id="speedMagnitude" style="font-size: 1.2em; color: #667eea;">0.0 m/s</span>
            </div>

            <div class="control-group">
                <label for="gridDensity">Grid Density</label>
                <input type="range" id="gridDensity" min="10" max="100" value="30" step="5">
                <span class="value-display" id="densityDisplay">30</span>
            </div>
            
            <div class="control-group">
                <label for="timeInterval">Time Interval (s)</label>
                <input type="number" id="timeInterval" value="10" step="1" min="1" max="30">
            </div>
            
            <div class="control-group">
                <label for="pathTimeStep">Path Time Step (s)</label>
                <input type="number" id="pathTimeStep" value="1" step="0.1" min="0.1" max="5">
            </div>
            
            <div class="control-group">
                <label for="initialAngle">Initial Heading (Â°)</label>
                <input type="range" id="initialAngle" min="0" max="360" value="0" step="15">
                <span class="value-display" id="angleDisplay">0Â°</span>
            </div>
            
            <div class="control-group">
                <button onclick="calculate()">Calculate Range</button>
            </div>

            <div class="control-group">
                <button onclick="endTurn()" id="endTurnBtn" disabled style="opacity: 0.5;">End Turn & Move Ship</button>
            </div>

            <div class="control-group">
                <button onclick="replayHistory()" id="replayBtn" disabled style="opacity: 0.5;">Replay All Moves</button>
            </div>
        </div>
        
        <canvas id="canvas" width="800" height="800"></canvas>
        
        <div class="status" id="status">Click on any point to see if the boat can reach it and visualize the path | Zoom: 100% | Use mouse wheel to zoom, right-click+drag to pan</div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(0, 255, 0, 0.8);"></div>
                <span>Reachable Position</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(255, 0, 0, 0.3);"></div>
                <span>Unreachable Position</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FFD700;"></div>
                <span>Boat Starting Position</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #4169E1;"></div>
                <span>Boat at Destination</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(65, 105, 225, 0.5);"></div>
                <span>Path Taken</span>
            </div>
        </div>
        
        <div class="info">
            <strong>How to use:</strong>
            <ul style="margin: 5px 0; padding-left: 20px;">
                <li>Click "Calculate Range" to show all reachable positions</li>
                <li>Click on any point to see if the boat can reach it</li>
                <li>If reachable, the blue path shows how the boat gets there</li>
                <li>The boat orientation at the destination is shown in blue</li>
                <li>Set initial velocities to simulate a moving start</li>
                <li><strong>Use mouse wheel to zoom in/out</strong></li>
                <li><strong>Right-click+drag to pan the view</strong></li>
            </ul>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let gridCalculated = false;
        let gridResults = {};
        let currentPath = null;
        let scale = 2; // pixels per meter - can be changed for zoom
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let moveHistory = []; // Store all previous moves
        let isAnimating = false;
        let animationProgress = 0;
        let isReplaying = false; // Track if we're in replay mode
        let replayShipState = null; // State of the replay ghost ship
        let shipWorldX = 0; // Ship's actual world position X
        let shipWorldY = 0; // Ship's actual world position Y
        
        // Update display values
        document.getElementById('turningRange').addEventListener('input', (e) => {
            document.getElementById('turningDisplay').textContent = e.target.value + 'Â°/s';
        });

        document.getElementById('gridDensity').addEventListener('input', (e) => {
            document.getElementById('densityDisplay').textContent = e.target.value;
        });

        document.getElementById('initialAngle').addEventListener('input', (e) => {
            document.getElementById('angleDisplay').textContent = e.target.value + 'Â°';
        });

        document.getElementById('targetRotation').addEventListener('input', (e) => {
            const currentAngle = parseFloat(document.getElementById('initialAngle').value);
            const relativeRotation = parseFloat(e.target.value);
            const targetAngle = currentAngle + relativeRotation;
            document.getElementById('targetRotationDisplay').textContent = `${relativeRotation}Â° (target: ${Math.round(targetAngle)}Â°)`;
        });

        // Update speed magnitude display when velocity changes
        document.getElementById('initialVx').addEventListener('input', updateSpeedMagnitude);
        document.getElementById('initialVy').addEventListener('input', updateSpeedMagnitude);

        function updateSpeedMagnitude() {
            const vx = parseFloat(document.getElementById('initialVx').value) || 0;
            const vy = parseFloat(document.getElementById('initialVy').value) || 0;
            const speed = Math.sqrt(vx * vx + vy * vy);
            document.getElementById('speedMagnitude').textContent = `${speed.toFixed(1)} m/s`;
        }

        function toggleFlightMode() {
            const mode = document.getElementById('flightMode').value;
            const coupledControls = document.querySelectorAll('.coupled-control');
            const decoupledControls = document.querySelectorAll('.decoupled-control');

            if (mode === 'coupled') {
                coupledControls.forEach(el => el.style.display = 'flex');
                decoupledControls.forEach(el => el.style.display = 'none');
            } else {
                coupledControls.forEach(el => el.style.display = 'none');
                decoupledControls.forEach(el => el.style.display = 'flex');
            }

            // Reset target rotation slider when switching modes
            document.getElementById('targetRotation').value = 0;
            const currentAngle = parseFloat(document.getElementById('initialAngle').value);
            document.getElementById('targetRotationDisplay').textContent = `0Â° (target: ${Math.round(currentAngle)}Â°)`;

            // Recalculate grid with new mode if grid was previously calculated
            if (gridCalculated) {
                calculate();
            }
        }
        
        // Add click handler
        canvas.addEventListener('click', handleCanvasClick);

        // Add zoom handler
        canvas.addEventListener('wheel', handleZoom);

        // Add pan handlers
        canvas.addEventListener('mousedown', handlePanStart);
        canvas.addEventListener('mousemove', handlePanMove);
        canvas.addEventListener('mouseup', handlePanEnd);
        canvas.addEventListener('mouseleave', handlePanEnd);
        
        function simulatePathToTargetDecoupled(targetX, targetY, params) {
            const {
                forwardThrust,
                backwardThrust,
                leftThrust,
                rightThrust,
                maxSpeed,
                rotationRate,
                timeLimit,
                initialHeading,
                targetHeading,
                initialVx,
                initialVy
            } = params;

            const rotationRateRad = rotationRate * Math.PI / 180;
            const initialHeadingRad = initialHeading * Math.PI / 180;
            const targetHeadingRad = targetHeading * Math.PI / 180;

            const numSegments = 10;
            const segmentTime = timeLimit / numSegments;

            // Initialize state
            let x = 0, y = 0;
            let vx = initialVx, vy = initialVy;
            let heading = initialHeadingRad;

            const path = [{x, y, vx, vy, heading, t: 0}];

            // Calculate total rotation needed
            let totalRotationNeeded = targetHeadingRad - initialHeadingRad;
            while (totalRotationNeeded > Math.PI) totalRotationNeeded -= 2 * Math.PI;
            while (totalRotationNeeded < -Math.PI) totalRotationNeeded += 2 * Math.PI;

            // Distribute rotation evenly across segments
            const rotationPerSegment = totalRotationNeeded / numSegments;
            const maxRotationPerSegment = rotationRateRad * segmentTime;

            for (let seg = 1; seg <= numSegments; seg++) {
                // Update heading (independent of velocity)
                let actualRotation = rotationPerSegment;
                actualRotation = Math.max(-maxRotationPerSegment, Math.min(maxRotationPerSegment, actualRotation));
                heading += actualRotation;

                // Calculate remaining distance and time
                const dx = targetX - x;
                const dy = targetY - y;
                const distToTarget = Math.sqrt(dx * dx + dy * dy);
                const remainingTime = (numSegments - seg + 1) * segmentTime;

                // Calculate desired velocity change in world frame
                const desiredVx = dx / remainingTime;
                const desiredVy = dy / remainingTime;
                const neededDvx = desiredVx - vx;
                const neededDvy = desiredVy - vy;

                // Convert needed acceleration to ship's local frame
                const cosH = Math.cos(heading);
                const sinH = Math.sin(heading);
                const localForward = neededDvx * cosH + neededDvy * sinH;
                const localRight = -neededDvx * sinH + neededDvy * cosH;

                // Determine thrust based on needed acceleration
                let thrustForward = 0;
                let thrustRight = 0;

                if (localForward > 0) {
                    thrustForward = Math.min(localForward / segmentTime, forwardThrust);
                } else {
                    thrustForward = Math.max(localForward / segmentTime, -backwardThrust);
                }

                if (localRight > 0) {
                    thrustRight = Math.min(localRight / segmentTime, rightThrust);
                } else {
                    thrustRight = Math.max(localRight / segmentTime, -leftThrust);
                }

                // Convert thrust back to world frame
                const worldAccelX = thrustForward * cosH - thrustRight * sinH;
                const worldAccelY = thrustForward * sinH + thrustRight * cosH;

                // Update velocity
                vx += worldAccelX * segmentTime;
                vy += worldAccelY * segmentTime;

                // Apply speed limit
                const currentSpeed = Math.sqrt(vx * vx + vy * vy);
                if (currentSpeed > maxSpeed) {
                    vx = vx * maxSpeed / currentSpeed;
                    vy = vy * maxSpeed / currentSpeed;
                }

                // Update position
                x += vx * segmentTime;
                y += vy * segmentTime;

                path.push({
                    x, y,
                    vx, vy,
                    heading,
                    t: seg * segmentTime,
                    thrustForward,
                    thrustRight
                });
            }

            const finalDist = Math.sqrt((targetX - x) * (targetX - x) + (targetY - y) * (targetY - y));
            const reachThreshold = 5.0;

            return {
                reached: finalDist <= reachThreshold,
                path: path,
                finalHeading: heading,
                finalX: x,
                finalY: y,
                targetX: targetX,
                targetY: targetY,
                finalDistance: finalDist
            };
        }

        function simulatePathToTarget(targetX, targetY, params) {
            const {
                maxAccel,
                maxDecel,
                maxSpeed,
                maxTurnRate,
                timeLimit,
                initialHeading,
                initialVx,
                initialVy,
                pathTimeStep
            } = params;

            // This function generates a segmented path that tries to reach the target
            // while respecting the 10-segment constraint

            // Convert to radians
            const maxTurnRad = maxTurnRate * Math.PI / 180;
            const initialHeadingRad = initialHeading * Math.PI / 180;

            // Number of segments (10 segments over the time interval)
            const numSegments = 10;
            const segmentTime = timeLimit / numSegments;

            // Initialize position and velocity
            let x = 0, y = 0;
            let vx = initialVx, vy = initialVy;
            let heading = initialHeadingRad;

            // Create path array
            const path = [{x, y, vx, vy, heading, t: 0}];

            // For each segment, calculate optimal turn and speed to reach target
            for (let seg = 1; seg <= numSegments; seg++) {
                // Calculate remaining time and current distance to target
                const remainingTime = (numSegments - seg + 1) * segmentTime;
                const dx = targetX - x;
                const dy = targetY - y;
                const distToTarget = Math.sqrt(dx * dx + dy * dy);

                // Calculate desired heading to target
                const desiredHeading = Math.atan2(dy, dx);

                // Calculate heading error
                let headingError = desiredHeading - heading;
                while (headingError > Math.PI) headingError -= 2 * Math.PI;
                while (headingError < -Math.PI) headingError += 2 * Math.PI;

                // Calculate turn for this segment (limited by max turn rate)
                const maxTurnThisSegment = maxTurnRad * segmentTime;
                let turnThisSegment = headingError / (numSegments - seg + 1); // Distribute remaining turn
                turnThisSegment = Math.max(-maxTurnThisSegment, Math.min(maxTurnThisSegment, turnThisSegment));

                // Update heading (rotate gradually toward target)
                heading += turnThisSegment;

                // Calculate desired velocity in heading direction
                const desiredSpeed = Math.min(distToTarget / remainingTime, maxSpeed);
                const desiredVx = desiredSpeed * Math.cos(heading);
                const desiredVy = desiredSpeed * Math.sin(heading);

                // Calculate velocity change needed
                const dvx = desiredVx - vx;
                const dvy = desiredVy - vy;
                const dvMagnitude = Math.sqrt(dvx * dvx + dvy * dvy);

                // Apply acceleration constraints to velocity change
                let maxDv;
                if (dvMagnitude > 0.001) {
                    // Check if we're accelerating or decelerating
                    const currentSpeed = Math.sqrt(vx * vx + vy * vy);
                    const newSpeed = Math.sqrt(desiredVx * desiredVx + desiredVy * desiredVy);

                    if (newSpeed > currentSpeed) {
                        maxDv = maxAccel * segmentTime;
                    } else {
                        maxDv = maxDecel * segmentTime;
                    }

                    // Limit velocity change by acceleration constraint
                    if (dvMagnitude > maxDv) {
                        vx += (dvx / dvMagnitude) * maxDv;
                        vy += (dvy / dvMagnitude) * maxDv;
                    } else {
                        vx = desiredVx;
                        vy = desiredVy;
                    }
                }

                // Move using current velocity
                x += vx * segmentTime;
                y += vy * segmentTime;

                // Add to path
                path.push({
                    x, y,
                    vx, vy,
                    heading,
                    t: seg * segmentTime
                });
            }

            // Check final distance to target
            const finalDist = Math.sqrt((targetX - x) * (targetX - x) + (targetY - y) * (targetY - y));

            // Determine if target is reachable based on final distance
            // Use a tolerance threshold - if we get within 5 meters, consider it reachable
            const reachThreshold = 5.0;
            const actuallyReachable = finalDist <= reachThreshold;

            return {
                reached: actuallyReachable,
                path: path,
                finalHeading: heading,
                finalX: x,
                finalY: y,
                targetX: targetX,
                targetY: targetY,
                finalDistance: finalDist
            };
        }
        
        
        function handleZoom(event) {
            event.preventDefault();

            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            // Get world coordinates before zoom
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const worldXBefore = (mouseX - centerX - panX) / scale;
            const worldYBefore = (mouseY - centerY - panY) / scale;

            // Zoom in or out
            const zoomFactor = event.deltaY < 0 ? 1.1 : 0.9;
            scale *= zoomFactor;

            // Clamp scale to reasonable values
            scale = Math.max(0.5, Math.min(10, scale));

            // Get world coordinates after zoom
            const worldXAfter = (mouseX - centerX - panX) / scale;
            const worldYAfter = (mouseY - centerY - panY) / scale;

            // Adjust pan to keep mouse position in same world location
            panX += (worldXAfter - worldXBefore) * scale;
            panY += (worldYAfter - worldYBefore) * scale;

            // Update zoom display
            updateZoomDisplay();

            // Redraw
            drawGrid();
            if (currentPath) {
                const targetX = currentPath.targetX;
                const targetY = currentPath.targetY;
                const screenX = centerX + targetX * scale + panX;
                const screenY = centerY + targetY * scale + panY;
                drawTarget(screenX, screenY, currentPath.reached);
                if (currentPath.reached) {
                    drawPath(currentPath.path);
                    drawBoatAtDestination(currentPath.finalX, currentPath.finalY, currentPath.finalHeading);
                }
            }
        }

        function handlePanStart(event) {
            // Only pan with right mouse button
            if (event.button === 2) {
                event.preventDefault();
                isPanning = true;
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
                canvas.style.cursor = 'grabbing';
            }
        }

        // Prevent context menu on right click
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        function handlePanMove(event) {
            if (isPanning) {
                const dx = event.clientX - lastMouseX;
                const dy = event.clientY - lastMouseY;

                panX += dx;
                panY += dy;

                lastMouseX = event.clientX;
                lastMouseY = event.clientY;

                // Redraw
                drawGrid();
                if (currentPath) {
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const targetX = currentPath.targetX;
                    const targetY = currentPath.targetY;
                    const screenX = centerX + targetX * scale + panX;
                    const screenY = centerY + targetY * scale + panY;
                    drawTarget(screenX, screenY, currentPath.reached);
                    if (currentPath.reached) {
                        drawPath(currentPath.path);
                        drawBoatAtDestination(currentPath.finalX, currentPath.finalY, currentPath.finalHeading);
                    }
                }
            }
        }

        function handlePanEnd(event) {
            if (isPanning) {
                isPanning = false;
                canvas.style.cursor = 'crosshair';
            }
        }

        function updateZoomDisplay() {
            const zoomPercent = Math.round((scale / 2) * 100);
            const status = document.getElementById('status');
            const statusText = status.textContent;
            const parts = statusText.split('|');
            if (parts.length >= 3) {
                parts[1] = ` Zoom: ${zoomPercent}% `;
                status.textContent = parts.join('|');
            } else {
                const baseText = parts[0];
                status.textContent = `${baseText} | Zoom: ${zoomPercent}% | Use mouse wheel to zoom, right-click+drag to pan`;
            }
        }

        function handleCanvasClick(event) {
            // Don't trigger click if we were panning or right-clicking
            if (event.button === 2) {
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;

            // Convert to world coordinates
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Calculate world position relative to ship's current position
            const worldX = (clickX - centerX - panX) / scale - shipWorldX;
            const worldY = (clickY - centerY - panY) / scale - shipWorldY;
            
            // Get parameters based on flight mode
            const flightMode = document.getElementById('flightMode').value;
            let params, result;

            if (flightMode === 'decoupled') {
                const currentHeading = parseFloat(document.getElementById('initialAngle').value);
                const relativeRotation = parseFloat(document.getElementById('targetRotation').value);
                const targetHeading = currentHeading + relativeRotation;

                params = {
                    forwardThrust: parseFloat(document.getElementById('forwardThrust').value),
                    backwardThrust: parseFloat(document.getElementById('backwardThrust').value),
                    leftThrust: parseFloat(document.getElementById('leftThrust').value),
                    rightThrust: parseFloat(document.getElementById('rightThrust').value),
                    maxSpeed: parseFloat(document.getElementById('maxSpeed').value),
                    rotationRate: parseFloat(document.getElementById('turningRange').value),
                    timeLimit: parseFloat(document.getElementById('timeInterval').value),
                    initialHeading: currentHeading,
                    targetHeading: targetHeading,
                    initialVx: parseFloat(document.getElementById('initialVx').value),
                    initialVy: parseFloat(document.getElementById('initialVy').value)
                };

                result = simulatePathToTargetDecoupled(worldX, worldY, params);
            } else {
                params = {
                    maxAccel: parseFloat(document.getElementById('maxAccel').value),
                    maxDecel: parseFloat(document.getElementById('maxDecel').value),
                    maxSpeed: parseFloat(document.getElementById('maxSpeed').value),
                    maxTurnRate: parseFloat(document.getElementById('turningRange').value),
                    timeLimit: parseFloat(document.getElementById('timeInterval').value),
                    initialHeading: parseFloat(document.getElementById('initialAngle').value),
                    initialVx: parseFloat(document.getElementById('initialVx').value),
                    initialVy: parseFloat(document.getElementById('initialVy').value),
                    pathTimeStep: parseFloat(document.getElementById('pathTimeStep').value)
                };

                result = simulatePathToTarget(worldX, worldY, params);
            }

            currentPath = result;

            // Log the full path details for debugging
            const pathDebug = {
                initialConditions: {
                    heading: params.initialHeading,
                    velocityX: params.initialVx,
                    velocityY: params.initialVy,
                    maxAccel: params.maxAccel,
                    maxDecel: params.maxDecel,
                    maxSpeed: params.maxSpeed,
                    maxTurnRate: params.maxTurnRate,
                    timeLimit: params.timeLimit
                },
                target: {
                    x: worldX,
                    y: worldY
                },
                reachable: result.reached,
                segments: result.path.map((segment, idx) => {
                    const speed = Math.sqrt(segment.vx * segment.vx + segment.vy * segment.vy);
                    const isValidSpeed = speed <= params.maxSpeed + 0.1;

                    return {
                        segmentIndex: idx,
                        time: segment.t,
                        position: {
                            x: segment.x,
                            y: segment.y
                        },
                        velocity: {
                            x: segment.vx,
                            y: segment.vy,
                            magnitude: speed
                        },
                        heading: {
                            radians: segment.heading,
                            degrees: segment.heading * 180 / Math.PI
                        },
                        valid: isValidSpeed,
                        validationDetails: {
                            speedOk: isValidSpeed,
                            speed: speed,
                            maxSpeed: params.maxSpeed
                        }
                    };
                }),
                finalState: {
                    position: {
                        x: result.finalX,
                        y: result.finalY
                    },
                    heading: {
                        radians: result.finalHeading,
                        degrees: result.finalHeading * 180 / Math.PI
                    },
                    distanceFromTarget: result.finalDistance,
                    reachThreshold: 5.0,
                    withinThreshold: result.finalDistance <= 5.0
                }
            };

            console.log(JSON.stringify(pathDebug, null, 2));

            // Enable/disable end turn button based on reachability
            const endTurnBtn = document.getElementById('endTurnBtn');
            if (result.reached) {
                endTurnBtn.disabled = false;
                endTurnBtn.style.opacity = '1';
            } else {
                endTurnBtn.disabled = true;
                endTurnBtn.style.opacity = '0.5';
            }

            // Update status
            const status = document.getElementById('status');
            const zoomPercent = Math.round((scale / 2) * 100);
            if (result.reached) {
                status.textContent = `âœ“ Target at (${worldX.toFixed(1)}, ${worldY.toFixed(1)}) is REACHABLE - Path shown in blue | Zoom: ${zoomPercent}% | Use mouse wheel to zoom, right-click+drag to pan`;
                status.style.background = '#d4f4dd';
                status.style.color = '#0d7829';
            } else {
                status.textContent = `âœ— Target at (${worldX.toFixed(1)}, ${worldY.toFixed(1)}) is UNREACHABLE | Zoom: ${zoomPercent}% | Use mouse wheel to zoom, right-click+drag to pan`;
                status.style.background = '#ffd4d4';
                status.style.color = '#d32f2f';
            }
            
            // Redraw with the new target
            drawGrid();

            // Convert world coordinates back to screen for drawing target
            // worldX/worldY are relative to ship, so add shipWorldX/Y to get absolute position
            const targetScreenX = centerX + (shipWorldX + worldX) * scale + panX;
            const targetScreenY = centerY + (shipWorldY + worldY) * scale + panY;
            drawTarget(targetScreenX, targetScreenY, result.reached);

            if (result.reached) {
                drawPath(result.path);
                drawBoatAtDestination(result.finalX, result.finalY, result.finalHeading);
            }
        }
        
        function drawPath(path) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Draw path as segments with bezier curves
            // Path coordinates are relative to ship, so add shipWorldX/Y
            for (let i = 0; i < path.length - 1; i++) {
                const x1 = centerX + (shipWorldX + path[i].x) * scale + panX;
                const y1 = centerY + (shipWorldY + path[i].y) * scale + panY;
                const x2 = centerX + (shipWorldX + path[i + 1].x) * scale + panX;
                const y2 = centerY + (shipWorldY + path[i + 1].y) * scale + panY;

                // Draw bezier curve segment
                ctx.strokeStyle = `rgba(65, 105, 225, ${0.7 - i * 0.3 / path.length})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x1, y1);

                // Calculate control points based on VELOCITY (not heading)
                // This makes the path curve based on movement direction, not ship rotation
                const segmentDist = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
                const controlDist = segmentDist * 0.33; // Control points at 1/3 of segment length

                // Get velocity directions
                const vx1 = path[i].vx;
                const vy1 = path[i].vy;
                const vx2 = path[i + 1].vx;
                const vy2 = path[i + 1].vy;

                const speed1 = Math.sqrt(vx1 * vx1 + vy1 * vy1);
                const speed2 = Math.sqrt(vx2 * vx2 + vy2 * vy2);

                // Control point 1: extends from point 1 in the direction of velocity1
                let cp1x, cp1y;
                if (speed1 > 0.01) {
                    const velAngle1 = Math.atan2(vy1, vx1);
                    cp1x = x1 + Math.cos(velAngle1) * controlDist;
                    cp1y = y1 + Math.sin(velAngle1) * controlDist;
                } else {
                    // If no velocity, use segment direction
                    cp1x = x1 + (x2 - x1) * 0.33;
                    cp1y = y1 + (y2 - y1) * 0.33;
                }

                // Control point 2: extends backward from point 2 in the direction of velocity2
                let cp2x, cp2y;
                if (speed2 > 0.01) {
                    const velAngle2 = Math.atan2(vy2, vx2);
                    cp2x = x2 - Math.cos(velAngle2) * controlDist;
                    cp2y = y2 - Math.sin(velAngle2) * controlDist;
                } else {
                    // If no velocity, use segment direction
                    cp2x = x1 + (x2 - x1) * 0.67;
                    cp2y = y1 + (y2 - y1) * 0.67;
                }

                // Draw cubic bezier curve
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2);
                ctx.stroke();
                
                // Draw boat at this segment position
                ctx.save();
                ctx.translate(x1, y1);
                ctx.rotate(path[i].heading);
                
                // Draw boat triangle at each position
                ctx.fillStyle = `rgba(65, 105, 225, ${0.5 - i * 0.3 / path.length})`;
                ctx.strokeStyle = `rgba(30, 58, 138, ${0.6 - i * 0.3 / path.length})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(8, 0);
                ctx.lineTo(-5, -4);
                ctx.lineTo(-5, 4);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.restore();
                
                // Draw segment number and time
                if (i > 0) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.font = 'bold 11px Arial';
                    ctx.fillText(`Seg ${i}`, x1 + 10, y1 - 5);
                    ctx.font = '10px Arial';
                    ctx.fillText(`t=${path[i].t.toFixed(1)}s`, x1 + 10, y1 + 8);

                    // Calculate and show speed
                    const speed = Math.sqrt(path[i].vx * path[i].vx + path[i].vy * path[i].vy);
                    const maxSpeed = parseFloat(document.getElementById('maxSpeed').value);

                    // Check if segment is valid (speed doesn't exceed max)
                    const isValid = speed <= maxSpeed + 0.1; // Small tolerance for floating point

                    if (!isValid) {
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.9)';
                        ctx.font = 'bold 12px Arial';
                        ctx.fillText('INVALID', x1 + 10, y1 + 32);
                    }

                    ctx.fillStyle = isValid ? 'rgba(255, 107, 107, 0.7)' : 'rgba(255, 0, 0, 0.9)';
                    ctx.fillText(`${speed.toFixed(1)}m/s`, x1 + 10, y1 + 20);
                }
                
                // Draw velocity indicator
                const vScale = 1.5;
                const vx = path[i].vx * vScale;
                const vy = path[i].vy * vScale;
                if (Math.sqrt(vx * vx + vy * vy) > 0.1) {
                    ctx.strokeStyle = `rgba(255, 107, 107, ${0.4 - i * 0.2 / path.length})`;
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x1 + vx, y1 + vy);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            
            // Highlight segment endpoints with circles
            for (let i = 0; i < path.length; i++) {
                const x = centerX + (shipWorldX + path[i].x) * scale + panX;
                const y = centerY + (shipWorldY + path[i].y) * scale + panY;
                
                ctx.fillStyle = 'rgba(65, 105, 225, 0.3)';
                ctx.strokeStyle = 'rgba(65, 105, 225, 0.8)';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }
        }
        
        function drawBoatAtDestination(x, y, heading) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // x, y are relative to ship position, so add shipWorldX/Y
            const screenX = centerX + (shipWorldX + x) * scale + panX;
            const screenY = centerY + (shipWorldY + y) * scale + panY;
            
            ctx.save();
            ctx.translate(screenX, screenY);
            ctx.rotate(heading);
            
            // Draw boat triangle (blue at destination)
            ctx.fillStyle = '#4169E1';
            ctx.strokeStyle = '#1e3a8a';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(12, 0);
            ctx.lineTo(-8, -6);
            ctx.lineTo(-8, 6);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            ctx.restore();
        }
        
        function drawTarget(x, y, reachable) {
            ctx.strokeStyle = reachable ? '#00FF00' : '#FF0000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(x, y, 8, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw crosshair
            ctx.beginPath();
            ctx.moveTo(x - 12, y);
            ctx.lineTo(x + 12, y);
            ctx.moveTo(x, y - 12);
            ctx.lineTo(x, y + 12);
            ctx.stroke();
        }
        
        function drawGrid() {
            // Clear canvas
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const gridDensity = parseInt(document.getElementById('gridDensity').value);

            // Use same world grid size as calculate function
            const worldGridSize = 400; // meters
            const gridStep = worldGridSize / gridDensity;

            // Update speed magnitude display
            updateSpeedMagnitude();
            
            // Draw grid lines
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;

            // Calculate visible grid range
            const startI = Math.floor((-centerX - panX) / (gridStep * scale));
            const endI = Math.ceil((canvas.width - centerX - panX) / (gridStep * scale));
            const startJ = Math.floor((-centerY - panY) / (gridStep * scale));
            const endJ = Math.ceil((canvas.height - centerY - panY) / (gridStep * scale));

            for (let i = startI; i <= endI; i++) {
                const pos = centerX + i * gridStep * scale + panX;
                if (pos >= 0 && pos <= canvas.width) {
                    ctx.beginPath();
                    ctx.moveTo(pos, 0);
                    ctx.lineTo(pos, canvas.height);
                    ctx.stroke();
                }
            }
            for (let j = startJ; j <= endJ; j++) {
                const pos = centerY + j * gridStep * scale + panY;
                if (pos >= 0 && pos <= canvas.height) {
                    ctx.beginPath();
                    ctx.moveTo(0, pos);
                    ctx.lineTo(canvas.width, pos);
                    ctx.stroke();
                }
            }
            
            // Draw grid points if calculated
            if (gridCalculated) {
                let debugCount = 0;
                for (let key in gridResults) {
                    const [i, j] = key.split(',').map(Number);
                    // Calculate relative position from ship
                    const relativeX = (i - gridDensity / 2) * gridStep;
                    const relativeY = (j - gridDensity / 2) * gridStep;
                    // Convert to absolute world position then to screen
                    const screenX = centerX + (shipWorldX + relativeX) * scale + panX;
                    const screenY = centerY + (shipWorldY + relativeY) * scale + panY;

                    if (debugCount === 0) {
                        // console.log('Grid dot debug:', {
                        //     key,
                        //     i, j,
                        //     gridDensity,
                        //     gridStep,
                        //     relativeX, relativeY,
                        //     shipWorldX, shipWorldY,
                        //     scale, panX, panY,
                        //     screenX, screenY
                        // });
                        debugCount++;
                    }

                    // Only draw if on screen
                    if (screenX >= -10 && screenX <= canvas.width + 10 &&
                        screenY >= -10 && screenY <= canvas.height + 10) {
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, 3, 0, Math.PI * 2);
                        ctx.fillStyle = gridResults[key] ? 'rgba(0, 255, 0, 0.8)' : 'rgba(255, 0, 0, 0.3)';
                        ctx.fill();
                    }
                }
            }
            
            // Draw boat starting position and heading
            const initialHeading = parseFloat(document.getElementById('initialAngle').value);
            const initialVx = parseFloat(document.getElementById('initialVx').value);
            const initialVy = parseFloat(document.getElementById('initialVy').value);

            ctx.save();
            ctx.translate(centerX + shipWorldX * scale + panX, centerY + shipWorldY * scale + panY);
            ctx.rotate(initialHeading * Math.PI / 180);
            
            // Draw boat triangle
            ctx.fillStyle = '#FFD700';
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(15, 0);
            ctx.lineTo(-10, -8);
            ctx.lineTo(-10, 8);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Draw heading indicator
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(50, 0);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.restore();
            
            // Draw velocity vector if non-zero
            if (initialVx !== 0 || initialVy !== 0) {
                ctx.save();
                ctx.translate(centerX + shipWorldX * scale + panX, centerY + shipWorldY * scale + panY);

                const vMag = Math.sqrt(initialVx * initialVx + initialVy * initialVy);
                const vAngle = Math.atan2(initialVy, initialVx);

                ctx.strokeStyle = '#FF6B6B';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(initialVx * scale * 2, initialVy * scale * 2);
                ctx.stroke();

                // Arrow head
                ctx.save();
                ctx.translate(initialVx * scale * 2, initialVy * scale * 2);
                ctx.rotate(vAngle);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-10, -5);
                ctx.lineTo(-10, 5);
                ctx.closePath();
                ctx.fillStyle = '#FF6B6B';
                ctx.fill();
                ctx.restore();

                ctx.restore();

                // Label velocity
                ctx.fillStyle = '#FF6B6B';
                ctx.font = 'bold 12px Arial';
                ctx.fillText(`Vâ‚€ = ${vMag.toFixed(1)} m/s`, centerX + shipWorldX * scale + panX + 20, centerY + shipWorldY * scale + panY - 20);
            }

            // Draw center marker at ship position
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(centerX + shipWorldX * scale + panX, centerY + shipWorldY * scale + panY, 4, 0, Math.PI * 2);
            ctx.fill();

            // Draw all previous moves as a continuous green line
            drawMoveHistory();
        }

        function drawMoveHistory() {
            if (moveHistory.length === 0) {
                return;
            }

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            ctx.strokeStyle = 'rgba(0, 200, 0, 0.6)';
            ctx.lineWidth = 4;

            // Track cumulative world position for drawing the path
            let cumulativeWorldX = 0;
            let cumulativeWorldY = 0;

            for (let moveIndex = 0; moveIndex < moveHistory.length; moveIndex++) {
                const move = moveHistory[moveIndex];
                const path = move.path;

                // Draw this move's path
                for (let i = 0; i < path.length - 1; i++) {
                    const x1 = centerX + (cumulativeWorldX + path[i].x) * scale + panX;
                    const y1 = centerY + (cumulativeWorldY + path[i].y) * scale + panY;
                    const x2 = centerX + (cumulativeWorldX + path[i + 1].x) * scale + panX;
                    const y2 = centerY + (cumulativeWorldY + path[i + 1].y) * scale + panY;

                    const segmentDist = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
                    const controlDist = segmentDist * 0.33;

                    // Use velocity for control points
                    const vx1 = path[i].vx;
                    const vy1 = path[i].vy;
                    const vx2 = path[i + 1].vx;
                    const vy2 = path[i + 1].vy;

                    const speed1 = Math.sqrt(vx1 * vx1 + vy1 * vy1);
                    const speed2 = Math.sqrt(vx2 * vx2 + vy2 * vy2);

                    let cp1x, cp1y, cp2x, cp2y;
                    if (speed1 > 0.01) {
                        const velAngle1 = Math.atan2(vy1, vx1);
                        cp1x = x1 + Math.cos(velAngle1) * controlDist;
                        cp1y = y1 + Math.sin(velAngle1) * controlDist;
                    } else {
                        cp1x = x1 + (x2 - x1) * 0.33;
                        cp1y = y1 + (y2 - y1) * 0.33;
                    }

                    if (speed2 > 0.01) {
                        const velAngle2 = Math.atan2(vy2, vx2);
                        cp2x = x2 - Math.cos(velAngle2) * controlDist;
                        cp2y = y2 - Math.sin(velAngle2) * controlDist;
                    } else {
                        cp2x = x1 + (x2 - x1) * 0.67;
                        cp2y = y1 + (y2 - y1) * 0.67;
                    }

                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2);
                    ctx.stroke();
                }

                // Update cumulative world position for next move
                const finalSegment = path[path.length - 1];
                cumulativeWorldX += finalSegment.x;
                cumulativeWorldY += finalSegment.y;
            }
        }
        
        function endTurn() {
            if (!currentPath || !currentPath.reached || isAnimating) {
                return;
            }

            // Store the move in history before executing it
            const moveRecord = {
                path: JSON.parse(JSON.stringify(currentPath.path)), // Deep copy
                startPanX: panX,
                startPanY: panY,
                targetX: currentPath.targetX,
                targetY: currentPath.targetY
            };
            moveHistory.push(moveRecord);

            // Enable replay button
            const replayBtn = document.getElementById('replayBtn');
            replayBtn.disabled = false;
            replayBtn.style.opacity = '1';

            // Animate the move
            animateMove(currentPath.path);
        }

        function animateMove(path) {
            isAnimating = true;
            animationProgress = 0;

            const finalSegment = path[path.length - 1];

            const animationDuration = 2000; // 2 seconds
            const startTime = Date.now();

            // Disable buttons during animation
            const endTurnBtn = document.getElementById('endTurnBtn');
            endTurnBtn.disabled = true;
            endTurnBtn.style.opacity = '0.5';

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / animationDuration, 1);

                // Easing function (ease-in-out)
                const eased = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                animationProgress = eased;

                // Draw current state
                drawGrid();
                drawAnimatedPath(path, eased);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Animation complete
                    isAnimating = false;
                    animationProgress = 0;
                    completeMove(finalSegment);
                }
            }

            animate();
        }

        function drawAnimatedPath(path, progress) {
            // Determine which segment we're currently in
            const totalSegments = path.length - 1;
            const currentSegmentFloat = progress * totalSegments;
            const currentSegmentIndex = Math.floor(currentSegmentFloat);
            const segmentProgress = currentSegmentFloat - currentSegmentIndex;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Draw completed segments
            for (let i = 0; i < Math.min(currentSegmentIndex, totalSegments); i++) {
                const x1 = centerX + (shipWorldX + path[i].x) * scale + panX;
                const y1 = centerY + (shipWorldY + path[i].y) * scale + panY;
                const x2 = centerX + (shipWorldX + path[i + 1].x) * scale + panX;
                const y2 = centerY + (shipWorldY + path[i + 1].y) * scale + panY;

                const segmentDist = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
                const controlDist = segmentDist * 0.33;

                // Use velocity for control points
                const vx1 = path[i].vx;
                const vy1 = path[i].vy;
                const vx2 = path[i + 1].vx;
                const vy2 = path[i + 1].vy;

                const speed1 = Math.sqrt(vx1 * vx1 + vy1 * vy1);
                const speed2 = Math.sqrt(vx2 * vx2 + vy2 * vy2);

                let cp1x, cp1y, cp2x, cp2y;
                if (speed1 > 0.01) {
                    const velAngle1 = Math.atan2(vy1, vx1);
                    cp1x = x1 + Math.cos(velAngle1) * controlDist;
                    cp1y = y1 + Math.sin(velAngle1) * controlDist;
                } else {
                    cp1x = x1 + (x2 - x1) * 0.33;
                    cp1y = y1 + (y2 - y1) * 0.33;
                }

                if (speed2 > 0.01) {
                    const velAngle2 = Math.atan2(vy2, vx2);
                    cp2x = x2 - Math.cos(velAngle2) * controlDist;
                    cp2y = y2 - Math.sin(velAngle2) * controlDist;
                } else {
                    cp2x = x1 + (x2 - x1) * 0.67;
                    cp2y = y1 + (y2 - y1) * 0.67;
                }

                ctx.strokeStyle = 'rgba(65, 105, 225, 0.7)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2);
                ctx.stroke();
            }

            // Draw current segment in progress
            if (currentSegmentIndex < totalSegments) {
                const i = currentSegmentIndex;
                const x1 = centerX + (shipWorldX + path[i].x) * scale + panX;
                const y1 = centerY + (shipWorldY + path[i].y) * scale + panY;
                const x2 = centerX + (shipWorldX + path[i + 1].x) * scale + panX;
                const y2 = centerY + (shipWorldY + path[i + 1].y) * scale + panY;

                const segmentDist = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
                const controlDist = segmentDist * 0.33;

                // Use velocity for control points
                const vx1 = path[i].vx;
                const vy1 = path[i].vy;
                const vx2 = path[i + 1].vx;
                const vy2 = path[i + 1].vy;

                const speed1 = Math.sqrt(vx1 * vx1 + vy1 * vy1);
                const speed2 = Math.sqrt(vx2 * vx2 + vy2 * vy2);

                let cp1x, cp1y, cp2x, cp2y;
                if (speed1 > 0.01) {
                    const velAngle1 = Math.atan2(vy1, vx1);
                    cp1x = x1 + Math.cos(velAngle1) * controlDist;
                    cp1y = y1 + Math.sin(velAngle1) * controlDist;
                } else {
                    cp1x = x1 + (x2 - x1) * 0.33;
                    cp1y = y1 + (y2 - y1) * 0.33;
                }

                if (speed2 > 0.01) {
                    const velAngle2 = Math.atan2(vy2, vx2);
                    cp2x = x2 - Math.cos(velAngle2) * controlDist;
                    cp2y = y2 - Math.sin(velAngle2) * controlDist;
                } else {
                    cp2x = x1 + (x2 - x1) * 0.67;
                    cp2y = y1 + (y2 - y1) * 0.67;
                }

                // Draw partial bezier curve
                ctx.strokeStyle = 'rgba(65, 105, 225, 0.7)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x1, y1);

                // Sample bezier curve and draw up to current progress
                const steps = 20;
                for (let j = 0; j <= steps * segmentProgress; j++) {
                    const t = j / steps;
                    const mt = 1 - t;
                    const bx = mt * mt * mt * x1 + 3 * mt * mt * t * cp1x + 3 * mt * t * t * cp2x + t * t * t * x2;
                    const by = mt * mt * mt * y1 + 3 * mt * mt * t * cp1y + 3 * mt * t * t * cp2y + t * t * t * y2;
                    ctx.lineTo(bx, by);
                }
                ctx.stroke();

                // Calculate boat position along the bezier curve
                const t = segmentProgress;
                const mt = 1 - t;
                const boatX = mt * mt * mt * x1 + 3 * mt * mt * t * cp1x + 3 * mt * t * t * cp2x + t * t * t * x2;
                const boatY = mt * mt * mt * y1 + 3 * mt * mt * t * cp1y + 3 * mt * t * t * cp2y + t * t * t * y2;

                // Get actual heading from path data
                const heading1 = path[i].heading;
                const heading2 = path[i + 1].heading;

                // Interpolate heading
                const boatHeading = heading1 + (heading2 - heading1) * segmentProgress;

                // Draw animated boat
                ctx.save();
                ctx.translate(boatX, boatY);
                ctx.rotate(boatHeading);

                ctx.fillStyle = '#FFD700';
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(15, 0);
                ctx.lineTo(-10, -8);
                ctx.lineTo(-10, 8);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                ctx.restore();
            }
        }

        function completeMove(finalSegment) {
            // Update ship's world position
            shipWorldX += finalSegment.x;
            shipWorldY += finalSegment.y;

            // Update initial velocity to final velocity
            document.getElementById('initialVx').value = finalSegment.vx.toFixed(2);
            document.getElementById('initialVy').value = finalSegment.vy.toFixed(2);

            // Update initial heading to final heading
            let finalHeadingDegrees = (finalSegment.heading * 180 / Math.PI);
            // Normalize to 0-360 range
            while (finalHeadingDegrees < 0) finalHeadingDegrees += 360;
            while (finalHeadingDegrees >= 360) finalHeadingDegrees -= 360;
            document.getElementById('initialAngle').value = Math.round(finalHeadingDegrees);
            document.getElementById('angleDisplay').textContent = Math.round(finalHeadingDegrees) + 'Â°';

            // Clear current path
            currentPath = null;
            gridCalculated = false;
            gridResults = {};

            // Update status
            const status = document.getElementById('status');
            status.textContent = `Turn ended! Ship moved to new position. Click "Calculate Range" to see new movement options. | Zoom: ${Math.round((scale / 2) * 100)}% | Use mouse wheel to zoom, right-click+drag to pan`;
            status.style.background = '#e8f4f8';
            status.style.color = '#333';

            // Redraw
            drawGrid();

            console.log('Turn ended. New ship state:', {
                position: { x: shipWorldX, y: shipWorldY },
                velocity: { x: finalSegment.vx, y: finalSegment.vy },
                heading: { radians: finalSegment.heading, degrees: finalHeadingDegrees },
                totalMoves: moveHistory.length
            });
        }

        function replayHistory() {
            if (moveHistory.length === 0 || isAnimating) {
                return;
            }

            console.log('Replaying all moves:', moveHistory);

            isReplaying = true;

            // Disable buttons
            const replayBtn = document.getElementById('replayBtn');
            replayBtn.disabled = true;
            replayBtn.style.opacity = '0.5';

            // Animate each move in sequence
            let currentMoveIndex = 0;

            function playNextMove() {
                if (currentMoveIndex >= moveHistory.length) {
                    // All moves replayed
                    isReplaying = false;
                    replayShipState = null;
                    replayBtn.disabled = false;
                    replayBtn.style.opacity = '1';
                    drawGrid();
                    console.log('Replay complete!');
                    return;
                }

                const move = moveHistory[currentMoveIndex];
                currentMoveIndex++;

                // Initialize replay ship state for this move
                replayShipState = {
                    currentPath: move.path,
                    progress: 0,
                    cumulativeWorldX: 0,
                    cumulativeWorldY: 0
                };

                // Calculate cumulative world position up to this move
                for (let i = 0; i < currentMoveIndex - 1; i++) {
                    const prevMove = moveHistory[i];
                    const prevFinalSegment = prevMove.path[prevMove.path.length - 1];
                    replayShipState.cumulativeWorldX += prevFinalSegment.x;
                    replayShipState.cumulativeWorldY += prevFinalSegment.y;
                }

                // Animate this move
                isAnimating = true;
                const animationDuration = 2000;
                const startTime = Date.now();

                function animate() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / animationDuration, 1);

                    const eased = progress < 0.5
                        ? 2 * progress * progress
                        : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                    replayShipState.progress = eased;

                    drawGrid();
                    drawReplayShip();

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // This move complete
                        isAnimating = false;

                        // Wait a bit then play next move
                        setTimeout(playNextMove, 500);
                    }
                }

                animate();
            }

            playNextMove();
        }

        function drawReplayShip() {
            if (!replayShipState || !replayShipState.currentPath) {
                return;
            }

            const path = replayShipState.currentPath;
            const progress = replayShipState.progress;

            // Determine which segment we're currently in
            const totalSegments = path.length - 1;
            const currentSegmentFloat = progress * totalSegments;
            const currentSegmentIndex = Math.floor(currentSegmentFloat);
            const segmentProgress = currentSegmentFloat - currentSegmentIndex;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Draw completed segments of current move
            for (let i = 0; i < Math.min(currentSegmentIndex, totalSegments); i++) {
                const x1 = centerX + (replayShipState.cumulativeWorldX + path[i].x) * scale + panX;
                const y1 = centerY + (replayShipState.cumulativeWorldY + path[i].y) * scale + panY;
                const x2 = centerX + (replayShipState.cumulativeWorldX + path[i + 1].x) * scale + panX;
                const y2 = centerY + (replayShipState.cumulativeWorldY + path[i + 1].y) * scale + panY;

                const segmentDist = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
                const controlDist = segmentDist * 0.33;

                // Use velocity for control points
                const vx1 = path[i].vx;
                const vy1 = path[i].vy;
                const vx2 = path[i + 1].vx;
                const vy2 = path[i + 1].vy;

                const speed1 = Math.sqrt(vx1 * vx1 + vy1 * vy1);
                const speed2 = Math.sqrt(vx2 * vx2 + vy2 * vy2);

                let cp1x, cp1y, cp2x, cp2y;
                if (speed1 > 0.01) {
                    const velAngle1 = Math.atan2(vy1, vx1);
                    cp1x = x1 + Math.cos(velAngle1) * controlDist;
                    cp1y = y1 + Math.sin(velAngle1) * controlDist;
                } else {
                    cp1x = x1 + (x2 - x1) * 0.33;
                    cp1y = y1 + (y2 - y1) * 0.33;
                }

                if (speed2 > 0.01) {
                    const velAngle2 = Math.atan2(vy2, vx2);
                    cp2x = x2 - Math.cos(velAngle2) * controlDist;
                    cp2y = y2 - Math.sin(velAngle2) * controlDist;
                } else {
                    cp2x = x1 + (x2 - x1) * 0.67;
                    cp2y = y1 + (y2 - y1) * 0.67;
                }

                ctx.strokeStyle = 'rgba(255, 165, 0, 0.7)'; // Orange for replay
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2);
                ctx.stroke();
            }

            // Draw current segment in progress
            if (currentSegmentIndex < totalSegments) {
                const i = currentSegmentIndex;
                const x1 = centerX + (replayShipState.cumulativeWorldX + path[i].x) * scale + panX;
                const y1 = centerY + (replayShipState.cumulativeWorldY + path[i].y) * scale + panY;
                const x2 = centerX + (replayShipState.cumulativeWorldX + path[i + 1].x) * scale + panX;
                const y2 = centerY + (replayShipState.cumulativeWorldY + path[i + 1].y) * scale + panY;

                const segmentDist = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
                const controlDist = segmentDist * 0.33;

                // Use velocity for control points
                const vx1 = path[i].vx;
                const vy1 = path[i].vy;
                const vx2 = path[i + 1].vx;
                const vy2 = path[i + 1].vy;

                const speed1 = Math.sqrt(vx1 * vx1 + vy1 * vy1);
                const speed2 = Math.sqrt(vx2 * vx2 + vy2 * vy2);

                let cp1x, cp1y, cp2x, cp2y;
                if (speed1 > 0.01) {
                    const velAngle1 = Math.atan2(vy1, vx1);
                    cp1x = x1 + Math.cos(velAngle1) * controlDist;
                    cp1y = y1 + Math.sin(velAngle1) * controlDist;
                } else {
                    cp1x = x1 + (x2 - x1) * 0.33;
                    cp1y = y1 + (y2 - y1) * 0.33;
                }

                if (speed2 > 0.01) {
                    const velAngle2 = Math.atan2(vy2, vx2);
                    cp2x = x2 - Math.cos(velAngle2) * controlDist;
                    cp2y = y2 - Math.sin(velAngle2) * controlDist;
                } else {
                    cp2x = x1 + (x2 - x1) * 0.67;
                    cp2y = y1 + (y2 - y1) * 0.67;
                }

                // Draw partial bezier curve
                ctx.strokeStyle = 'rgba(255, 165, 0, 0.7)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x1, y1);

                // Sample bezier curve and draw up to current progress
                const steps = 20;
                for (let j = 0; j <= steps * segmentProgress; j++) {
                    const t = j / steps;
                    const mt = 1 - t;
                    const bx = mt * mt * mt * x1 + 3 * mt * mt * t * cp1x + 3 * mt * t * t * cp2x + t * t * t * x2;
                    const by = mt * mt * mt * y1 + 3 * mt * mt * t * cp1y + 3 * mt * t * t * cp2y + t * t * t * y2;
                    ctx.lineTo(bx, by);
                }
                ctx.stroke();

                // Calculate boat position along the bezier curve
                const t = segmentProgress;
                const mt = 1 - t;
                const boatX = mt * mt * mt * x1 + 3 * mt * mt * t * cp1x + 3 * mt * t * t * cp2x + t * t * t * x2;
                const boatY = mt * mt * mt * y1 + 3 * mt * mt * t * cp1y + 3 * mt * t * t * cp2y + t * t * t * y2;

                // Get actual heading from path data
                const heading1 = path[i].heading;
                const heading2 = path[i + 1].heading;

                // Interpolate heading
                const boatHeading = heading1 + (heading2 - heading1) * segmentProgress;

                // Draw replay ghost boat (orange/transparent)
                ctx.save();
                ctx.translate(boatX, boatY);
                ctx.rotate(boatHeading);

                ctx.fillStyle = 'rgba(255, 165, 0, 0.7)';
                ctx.strokeStyle = 'rgba(200, 100, 0, 0.9)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(15, 0);
                ctx.lineTo(-10, -8);
                ctx.lineTo(-10, 8);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                ctx.restore();
            }
        }

        function calculate() {
            const flightMode = document.getElementById('flightMode').value;
            const gridDensity = parseInt(document.getElementById('gridDensity').value);
            const timeLimit = parseFloat(document.getElementById('timeInterval').value);
            const initialHeading = parseFloat(document.getElementById('initialAngle').value);
            const initialVx = parseFloat(document.getElementById('initialVx').value);
            const initialVy = parseFloat(document.getElementById('initialVy').value);

            let params;

            if (flightMode === 'decoupled') {
                const relativeRotation = parseFloat(document.getElementById('targetRotation').value);
                const targetHeading = initialHeading + relativeRotation;

                params = {
                    forwardThrust: parseFloat(document.getElementById('forwardThrust').value),
                    backwardThrust: parseFloat(document.getElementById('backwardThrust').value),
                    leftThrust: parseFloat(document.getElementById('leftThrust').value),
                    rightThrust: parseFloat(document.getElementById('rightThrust').value),
                    maxSpeed: parseFloat(document.getElementById('maxSpeed').value),
                    rotationRate: parseFloat(document.getElementById('turningRange').value),
                    timeLimit,
                    initialHeading,
                    targetHeading,
                    initialVx,
                    initialVy
                };
            } else {
                params = {
                    maxAccel: parseFloat(document.getElementById('maxAccel').value),
                    maxDecel: parseFloat(document.getElementById('maxDecel').value),
                    maxSpeed: parseFloat(document.getElementById('maxSpeed').value),
                    maxTurnRate: parseFloat(document.getElementById('turningRange').value),
                    timeLimit,
                    initialHeading,
                    initialVx,
                    initialVy
                };
            }
            
            // Calculate grid in world coordinates (independent of zoom/pan)
            // gridDensity is number of grid cells, gridStep is world units per cell
            const worldGridSize = 400; // Total world space size (meters)
            const gridStep = worldGridSize / gridDensity;

            // Calculate reachability for each grid point
            // Grid points are calculated relative to ship's current position
            gridResults = {};
            for (let i = 0; i <= gridDensity; i++) {
                for (let j = 0; j <= gridDensity; j++) {
                    // Calculate relative position from ship
                    const relativeX = (i - gridDensity / 2) * gridStep;
                    const relativeY = (j - gridDensity / 2) * gridStep;

                    let result;
                    if (flightMode === 'decoupled') {
                        result = simulatePathToTargetDecoupled(relativeX, relativeY, params);
                    } else {
                        result = simulatePathToTarget(relativeX, relativeY, params);
                    }
                    gridResults[`${i},${j}`] = result.reached;
                }
            }
            
            gridCalculated = true;
            currentPath = null;
            drawGrid();

            const zoomPercent = Math.round((scale / 2) * 100);
            document.getElementById('status').textContent = `Grid calculated! Click on any point to see the path. | Zoom: ${zoomPercent}% | Use mouse wheel to zoom, right-click+drag to pan`;
        }
        
        // Initial draw
        drawGrid();
    </script>
</body>
</html>